%%=============================================================================
%% API's
%%=============================================================================


\chapter{\IfLanguageName{dutch}{Netwerkverzoeken}{Network calls}}
\label{ch:api}
Wanneer een app gebruik wilt maken van niet lokale data moet een netwerk connectie tot stand brengen. Daarom is het voor elke nieuwe app ontwikkelaar belangrijk om op de hoogte te zijn van de werking hiervan.

\section{Opzet}
Voor dit deel van het onderzoek werd onder andere gebruik gemaakt van een online API en de al dan niet ingebouwde platform specifieke functionaliteiten voor het aanspreken van de services. Het onderzoek werd gevoerd gebruik makend van simpele, gratis, goed gedocumenteerde API's. In de onderzoeksapplicatie werden verschillende API calls gedaan die later in dit hoofdstuk worden beschreven.

Wanneer een Android app een netwerk verzoek wilt uitvoeren moet deze app eerst permissie hebben gekregen om het internet te gebruiken. Wegens Android privacy redenen kan de gebruiker dit dus uitzetten. Deze permissie dient toegevoegd te worden in het manifest.

Hierbij worden simpele codevoorbeelden toegevoegd om inzicht te verwerven in deze concepten.

\section{Android}
De meeste apps die in connectie staan met het netwerk maken gebruik van HTTP om data te versturen en te ontvangen over het internet. Android voorziet hiervoor twee clients: HttpURLConnection en Apache HTTP Client. Daarbuiten kunnen ook een aantal goed ontwikkelde frameworks gebruikt worden. Enkele van de libraries die hiervoor in Android makkelijk te gebruiken zijn, zijn OKHttp, Volley, Retrofit, Picasso, Fresco.

\subsection{Google’s HTTP clients}\\
In de begin jaren van Android waren juist twee HTTP Clients beschikbaar. Beide waren niet goed geïntegreerd in het platform. HttpUrlConnection had last van enkele bugs terwijl Apache Clients niet meer werd geüpdatet. Terwijl Google ervoor koos om Apache-based AndroidHttpClient later deprecated te maken besloten ze om de bugs in HttpURLConnection wel op te lossen. Binnen Android is dit een vlugge gemakkelijke manier om een netwerk request uit te voeren. Echter wordt deze al snel ingewikkeld als deze verder uitbreidt.

\begin{lstlisting}[language=Kotlin, caption=Simpel Android HttpUrlCpnnection voorbeeld]
val url = URL("http://www.android.com/")
val urlConnection: HttpURLConnection 
    = url.openConnection() as HttpURLConnection
try {
    val inp: InputStream 
        = BufferedInputStream(urlConnection.getInputStream())
    //Do something with response
} finally {
    urlConnection.disconnect()
}
\end{lstlisting}

\subsection{OKHttp}\\
Google besloot uiteindelijk om de goed ondersteunde OKHttp library op te nemen in Android. Hierdoor konden ze, zoals hiervoor vermeld, de Apache library deprecated maken. Ondertussen heeft de OKHttp library al een heleboel extra features die netwerken gemakkelijker maken. Zo voorziet de library een goede oplossing voor asynchrone requests die sinds Android 3.0 op een aparte thread moeten worden uitgevoerd. Om vergelijkbare logica met HttpUrlConnection te implementeren, zou een veel omvangrijkere implementatie moeten worden bedacht om AsyncTask-wrapper of afzonderlijke threads te gebruiken.

\begin{lstlisting}[language=Kotlin, caption=Sipmel Android OKHttp voorbeeld]
val client = OkHttpClient()
val url = URL("http://www.android.com/")

fun run() {
    val request = Request.Builder()
    .url(url)
    .build()
    
    client.newCall(request).execute().use { response ->
        if (!response.isSuccessful)
             throw IOException("Unexpected code $response")
        //Do something with response
    }
}
\end{lstlisting}

\subsection{Volley}\\
Na het zien van de snelle toename in populariteit van OKHttp, besloot Google om Volley te lanceren. Alles in Volley is voortgebouwd op HttpUrlConnection. Ondanks de late release van de library, heeft deze zijn voor- en nadelen. Zo voorziet volley een paar handige opties zoals automatische planning van netwerkverzoeken, meerdere gelijktijdige netwerkverbindingen, ondersteuning voor prioritering van verzoeken… maar maakt de library bijvoorbeeld gebruik van een hardcoded networking thread pool size.

\begin{lstlisting}[language=Kotlin, caption=Simpel Android Volley voorbeeld]
val queue = Volley.newRequestQueue(this)
val url = "http://www.android.com/"

val stringRequest = StringRequest(Request.Method.GET, url,
Response.Listener<String> { response ->
    //Do something with response
},
Response.ErrorListener {
    //Do something with error
})

// Add the request to the RequestQueue.
queue.add(stringRequest)
\end{lstlisting}

\subsection{Retrofit}\\
Retrofit is een speciale HTTP-client voor Android en Java. De type-safe client maakt verbinding met een REST-webservice door de API te vertalen naar Java-interfaces. Deze krachtige library maakt het gemakkelijk om JSON- of XML-gegevens te gebruiken, omgezet in Plain Old Java Objects. De open-source Retrofit library heeft zijn basis bovenop enkele andere krachtige bibliotheken en tools gebouwd. Het maakt gebruik van OKHttp om netwerkverzoeken af te handelen.

\begin{lstlisting}[language=Kotlin, caption=Simpel Android Retrofit voorbeeld]
data class SomeData(var property: String)
    
interface ApiInterface {
    @GET("/")
    fun get() : Call<List<SomeData>>
        
    companion object {
        val url = "..."
        fun create() : ApiInterface {
            val retrofit = Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(url)
            .build()
            return retrofit.create(ApiInterface::class.java)
        }
    }
}

val apiInterface = ApiInterface.create().get()

apiInterface.enqueue( object : Callback<List<SomeData>>{
    override fun onResponse(call: Call<List<SomeData>>?, response: Response<List<SomeData>>?) {
        if(response?.body() != null)
            //Do something with result
    }
    override fun onFailure(call: Call<List<Movie>>?, t: Throwable?) {
        //Do something with error
    }
})
\end{lstlisting}

\subsectiontbf{Moshi}\\
Moshi is een moderne JSON-bibliotheek voor Android en Java. Het maakt het gemakkelijk om JSON in Java-objecten om te zetten en het kan even gemakkelijk Java-objecten serialiseren naar JSON. Moshi heeft ingebouwde ondersteuning voor het lezen en schrijven van de belangrijkste gegevenstypen van Java: int, float, char... maar ook Arrays, Collections, Lists, Sets, Maps, Strings en Enums.

\subsection{Picasso}\\
Picasso is specifiek voor afbeeldingen, met een sterke HTTP downloading en caching library. Zowel Picasso als Retrofit kunnen worden geconfigureerd om OkHttpClient als de standaard HTTP-client te gebruiken.

\begin{lstlisting}[language=Kotlin, caption=Simpel Android Picasso voorbeeld]
val imageUri = "https://...jpg"
val imageView = findViewById<ImageView>(R.id.imageId)
Picasso.get().load(imageUri).into(imageView)
\end{lstlisting}

\subsection{Glide}\\
Glide is een snel en efficiënt open source-framework voor mediabeheer en het laden van afbeeldingen. Deze library is vergelijkbaar met Picasso, maar voorziet een aantal extra features zoals GIF animaties en thumbnail generatie. Glide gebruikt standaard een aangepaste, op HttpUrlConnection gebaseerde stack, maar bevat in plaats daarvan ook utility libraries die kunnen worden verbonden met het Volley of OkHttp.

\begin{lstlisting}[language=Kotlin, caption=Simpel Android Glide voorbeeld]
val url = "https://...jpg"
Glide.with(itemView) 
.load(url)
.centerCrop()
.placeholder(R.drawable.ic_image_place_holder)
.error(R.drawable.ic_broken_image)
.fallback(R.drawable.ic_no_image)
.into(itemView.ivPhoto)
\end{lstlisting}

\section{Flutter}
Voor Flutter wordt vooral gebruik gemaakt van de HTTP Package library.

\subsection{http}\\
Deze package, uitgebracht door dart, bevat een reeks functies en klassen op hoog niveau die het gemakkelijk maken om HTTP-bronnen te gebruiken.
\begin{lstlisting}[language=Dart, caption=Simpel Flutter http voorbeeld]
import 'package:http/http.dart' as http;
var result = await http.get(Uri.parse('https://flutterdevs.com'));
\end{lstlisting}

\subsection{dio}\\
Een krachtige Http-client voor Dart, die ondersteuning biedt voor interceptors, algemene configuratie, FormData, annulering van aanvragen, downloaden van bestanden, time-out enz.
\begin{lstlisting}[language=Kotlin, caption=Simpel Flutter dio voorbeeld]
import 'package:dio/dio.dart';
void getHttp() async {
    try {
        var response = await Dio().get('http://www.google.com');
        print(response);
    } catch (e) {
        print(e);
    }
}
\end{lstlisting}

\subsection{cached\_network\_image}\\
Een Flutter library om afbeeldingen van het internet weer te geven en in de cachemap te bewaren. De CachedNetworkImage kan direct of via de ImageProvider worden gebruikt. Het bevat momenteel geen caching. Dit is een library die niet werd uitgebracht door Flutter of Dart maar is zeer populair onder de community en wordt goed onderhouden.
\begin{lstlisting}[language=Kotlin, caption=Simpel Flutter http voorbeeld]
CachedNetworkImage(
imageUrl: "http://via.placeholder.com/350x150",
placeholder: (context, url) => CircularProgressIndicator(),
errorWidget: (context, url, error) => Icon(Icons.error),
),

Image(image: CachedNetworkImageProvider(url))
\end{lstlisting}

\section{Conclusie}
Zoals in vorige hoofdstuk \ref{ch:asynchroon} ook het geval was, is ook hier Android veel rijker aan keuzes. De code complexiteit van deze netwerk opties was in Android vele malen complexer als in Flutter. Hieruit kan geconcludeerd worden dat de libraries voor API calls minder gebruiksvriendelijk zijn. Flutter daarentegen biedt een simpele, overzichtelijke, goed gedocumenteerde manier voor het uitvoeren van API calls. De libraries zijn toegankelijk voor nieuwe ontwikkelaars.