%%=============================================================================
%% Complexiteit
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Code Complexiteit}{Code Complexity}}
\label{ch:complexiteit}
In dit hoofdstuk werd gekeken naar de complexiteit van de geschreven code. Dit schetst een beeld van de toegankelijkheid van de taal. Code complexiteit gaat in vele gevallen gepaard met het aantal lijnen code. Eerst en vooral is het niet altijd beter om alles in één beknopte lijn code te schrijven. Het is zo dat bij het schrijven van applicaties, vaak samengewerkt wordt met anderen aan dezelfde code. Complexe code is moeilijker om lezen en kan soms verkeerd geïnterpreteerd worden. Het is dus niet verkeerd om soms een extra lijn code te schrijven voor de complexiteit te verminderen. Echter moet hier een gezonde middenweg in gezocht worden aangezien veel lijnen code ook voor een complexe codebase kan zorgen.

\section{Opzet}
Er zijn verschillende manieren om de code complexiteit van een stuk code te bepalen. Veel van deze, hoewel ze een goede weergave van complexiteit opleveren, lenen zich niet voor gemakkelijke meting. Enkele van de meest gebruikte statistieken zijn:
\begin{itemize}
    \item Cyclomatic complexity
    \item Halstead complexity measures
    \item Essential complexity
\end{itemize}

Voor dit deel van het onderzoek werd geen gebruik gemaakt van deze algoritmes, daarvoor waren de onderzoeksapplicaties te klein. Dit zou leiden insignificante verschillen van de resultaten. In plaats daarvan werd een notificatie lijst gemaakt. De opbouw van de code, het aantal lijnen code en de ontwikkelingstijd werden hierbij in rekening gehouden.

\section{Resultaten}
\begin{figure}
    \caption{Android Activity code snippet voor het maken van een notificatielijst}
     \label{fig:h8Android}
    \centering
\includegraphics[width=15cm]{h8AndroidFragment.png}
\end{figure}

\begin{figure}
    \caption{Flutter code snipper voor het maken van een notificatielijst}
         \label{fig:h8Flutter}
    \centering
    \includegraphics[width=15cm]{h8Flutter.png}
\end{figure}

\textbf{Lijnen code}\\
De Flutter notificatielijst bedroeg één bestand met daarin 

. Native iOS had de laagste grootte van projectbestanden en app-grootte, maar een aanzienlijk groter aantal coderegels dan de andere builds. De native Android had het meeste aantal bestanden gemaakt en vereiste minder coderegels dan de native iOS.

\textbf{Code complexity}\\
Voor dit deel v Het werd met name gekozen omdat het de meeste code bevatte die werd geschreven en omdat de andere weergave alleen een afbeelding en een titel bevatte. De code die in deze sectie wordt weergegeven, is slechts een deel van de codebases van de applicatie.

Figuur \ref{fig:h8Flutter} laat zien hoe Flutter het toe staat om de visuele opbouw van een scherm in hetzelfde codeblok te verwerken als de functionele code achter het scherm. In de afbeelding is er een child parent relatie voor de widget elementen. De code laat zien dat er een widget is die is gebouwd om geneste widgets te retourneren. Het kind naar de hoofdcontainers Padding, toont het maken van een ListView Flutter-widget. Deze weergave retourneert een lijstweergave met 20 items en 20 containeritems.

In figuur \ref{fig:h8Android3} verklaart de Android Kotlin-toepassingscode het weergavemodel en importeert de benodigde items voor de code. Alles gebeurt in de onCreateView-functie, die de XML-lay-out voor de notificatielijst opblaast en een array creëert met dezelfde strings "Notification" die het als gegevens injecteert in het reeds bestaande ListView XML-doel met de id "products". De native code van Android heeft veel omgevingsspecifieke variabelen waarmee een ontwikkelaar rekening moet houden.

Deze code is relatief kort voor zijn doel en is gemakkelijk gestructureerd voor een beginner in mobiele ontwikkeling. Er zijn taalspecifieke delen van de code, maar verder zou het waarschijnlijk kunnen worden begrepen door iemand die kennis heeft van andere talen.

\textbf{Development time}\\
Zoals te zien valt in tabel \ref{table:ontwikkelingstijd}, is het meeste tijd naar de ontwikkeling van de native Android app gegaan. De toegankelijkheid van Dart samen met krachtige simpliciteit van Flutter leidde tot een snelle vooruitgang binnen de ontwikkeling van de onderzoeksapplicatie. De hot reload functionaliteit die het toestaat om een applicatie in enkele seconden up te daten op basis van wijzigingen in de codebase is dan ook een goede bijdrage aan het platform. Android daarentegen verwacht meer boilerplate code met een vaste structuur. De opbouw van een layout is gemakkelijk met de drag en drop functionaliteit, maar het linken van deze views aan code is dan weer moeilijker.

\begin{table}
    \begin{center}
        \caption{Ontwikkelingstijd voor elke applicatie}
        \label{table:ontwikkelingstijd}
        \begin{tabular}{ |l|l| }
            \hline
            & \textbf{Totaal}\\
            \hline
            \textbf{Android} & 26 Uur\\ 
            \hline
            \textbf{Flutter} & 20 Uur\\ 
            \hline
        \end{tabular}
    \end{center}
\end{table}

\section{Conclusie}
Als we naar de resultaten als geheel kijken, wint Flutter de meeste categorieën in het ontwikkelingsgebied. Er zijn echter enkele verschillen die interessant zijn om op te letten bij het vergelijken van Flutter met native builds.